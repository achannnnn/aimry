import Foundation
import Capacitor

@objc(CAPBrowserPlugin)
public class CAPBrowserPlugin: CAPPlugin, CAPBridgedPlugin {
    public let identifier = "CAPBrowserPlugin"
    public let jsName = "Browser"
    public let pluginMethods: [CAPPluginMethod] = [
        CAPPluginMethod(name: "open", returnType: CAPPluginReturnPromise),
        CAPPluginMethod(name: "close", returnType: CAPPluginReturnPromise)
    ]
    private let implementation = Browser()

    private func currentViewController() -> UIViewController? {
        let scenes = UIApplication.shared.connectedScenes
        let windowScenes = scenes.compactMap { $0 as? UIWindowScene }
        let windows = windowScenes.flatMap { $0.windows }
        let keyWindow = windows.first { $0.isKeyWindow }
        let root = keyWindow?.rootViewController
        return topMostViewController(from: root)
    }

    private func topMostViewController(from root: UIViewController?) -> UIViewController? {
        if let navigationController = root as? UINavigationController {
            return topMostViewController(from: navigationController.visibleViewController)
        }
        if let tabBarController = root as? UITabBarController {
            return topMostViewController(from: tabBarController.selectedViewController)
        }
        if let presented = root?.presentedViewController {
            return topMostViewController(from: presented)
        }
        return root
    }

    private func parseHexColor(_ input: String) -> UIColor? {
        let hex = input
            .trimmingCharacters(in: .whitespacesAndNewlines)
            .replacingOccurrences(of: "#", with: "")

        func component(_ value: UInt32) -> CGFloat {
            return CGFloat(value) / 255.0
        }

        if hex.count == 6, let rgb = UInt32(hex, radix: 16) {
            let r = (rgb >> 16) & 0xFF
            let g = (rgb >> 8) & 0xFF
            let b = rgb & 0xFF
            return UIColor(red: component(r), green: component(g), blue: component(b), alpha: 1.0)
        }

        // Treat 8-digit hex as RRGGBBAA (common web format)
        if hex.count == 8, let rgba = UInt32(hex, radix: 16) {
            let r = (rgba >> 24) & 0xFF
            let g = (rgba >> 16) & 0xFF
            let b = (rgba >> 8) & 0xFF
            let a = rgba & 0xFF
            return UIColor(red: component(r), green: component(g), blue: component(b), alpha: component(a))
        }

        return nil
    }

    private func intOption(_ call: CAPPluginCall, _ key: String) -> Int? {
        if let value = call.options[key] as? Int {
            return value
        }
        if let value = call.options[key] as? Double {
            return Int(value)
        }
        if let value = call.options[key] as? NSNumber {
            return value.intValue
        }
        return nil
    }

    @objc func open(_ call: CAPPluginCall) {
        // validate the URL
        guard let urlString = call.options["url"] as? String, let url = URL(string: urlString) else {
            call.unimplemented("Must provide a valid URL to open")
            return
        }
        // extract the optional parameters
        var color: UIColor?
        if let toolbarColor = call.options["toolbarColor"] as? String {
            color = parseHexColor(toolbarColor)
        }
        let style = self.presentationStyle(for: call.options["presentationStyle"] as? String)
        // prepare for display
        guard implementation.prepare(for: url, withTint: color, modalPresentation: style), let viewController = implementation.viewController else {
            call.unimplemented("Unable to display URL")
            return
        }
        implementation.browserEventDidOccur = { [weak self] (event) in
            if event == .finished {
                DispatchQueue.main.async { [weak self] in
                    self?.implementation.viewController?.dismiss(animated: true, completion: {
                        self?.notifyListeners(event.listenerEvent, data: nil)
                    })
                }
            } else {
                self?.notifyListeners(event.listenerEvent, data: nil)
            }
        }
        // display
        DispatchQueue.main.async { [weak self] in
            guard let presenter = self?.currentViewController() else {
                call.unimplemented("Unable to determine presenting view controller")
                return
            }
            if style == .popover {
                if let width = self?.intOption(call, "width"), let height = self?.intOption(call, "height") {
                    self?.setCenteredPopover(viewController, size: CGSize.init(width: width, height: height))
                } else {
                    self?.setCenteredPopover(viewController)
                }
            }
            presenter.present(viewController, animated: true, completion: {
                call.resolve()
            })
        }
    }

    @objc func close(_ call: CAPPluginCall) {
        DispatchQueue.main.async { [weak self] in
            if self?.implementation.viewController != nil {
                self?.implementation.viewController?.dismiss(animated: true) {
                    call.resolve()
                    self?.implementation.cleanup()
                }
            } else {
                call.unimplemented("No active window to close!")
            }
        }
    }

    private func presentationStyle(for style: String?) -> UIModalPresentationStyle {
        if let style = style, style == "popover" {
            return .popover
        }
        return .fullScreen
    }
}

private extension BrowserEvent {
    var listenerEvent: String {
        switch self {
        case .loaded:
            return "browserPageLoaded"
        case .finished:
            return "browserFinished"
        }
    }
}
